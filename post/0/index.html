<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#578acc"><link rel="manifest" href="/manifest.json"><link rel="shortcut icon" href="/favicon.png"><title>Javascript 非同步編程</title><link href="/static/css/main.9069d846.css" rel="stylesheet"></head><body><div id="root"><div data-reactroot=""><div id="flyChicken"><canvas width="800" height="600"></canvas></div><div class="header"><h2 class="name"><a href="/">Max Ho</a></h2><div class="links"><a href="https://www.facebook.com/he.z.min.1" target="_blank" rel="noopener noreferrer"><span><!--?xml version="1.0" encoding="iso-8859-1"?--><svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="60.734px" height="60.733px" viewBox="0 0 60.734 60.733" style="enable-background:new 0 0 60.734 60.733;" xml:space="preserve"><path d="M57.378,0.001H3.352C1.502,0.001,0,1.5,0,3.353v54.026c0,1.853,1.502,3.354,3.352,3.354h29.086V37.214h-7.914v-9.167h7.914 v-6.76c0-7.843,4.789-12.116,11.787-12.116c3.355,0,6.232,0.251,7.071,0.36v8.198l-4.854,0.002c-3.805,0-4.539,1.809-4.539,4.462 v5.851h9.078l-1.187,9.166h-7.892v23.52h15.475c1.852,0,3.355-1.503,3.355-3.351V3.351C60.731,1.5,59.23,0.001,57.378,0.001z"></path></svg></span></a><a href="https://github.com/wl00887404" target="_blank" rel="noopener noreferrer"><span><!--?xml version="1.0" encoding="iso-8859-1"?--><svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="438.549px" height="438.549px" viewBox="0 0 438.549 438.549" style="enable-background:new 0 0 438.549 438.549;" xml:space="preserve"><path d="M409.132,114.573c-19.608-33.596-46.205-60.194-79.798-79.8C295.736,15.166,259.057,5.365,219.271,5.365 c-39.781,0-76.472,9.804-110.063,29.408c-33.596,19.605-60.192,46.204-79.8,79.8C9.803,148.168,0,184.854,0,224.63 c0,47.78,13.94,90.745,41.827,128.906c27.884,38.164,63.906,64.572,108.063,79.227c5.14,0.954,8.945,0.283,11.419-1.996	c2.475-2.282,3.711-5.14,3.711-8.562c0-0.571-0.049-5.708-0.144-15.417c-0.098-9.709-0.144-18.179-0.144-25.406l-6.567,1.136 c-4.187,0.767-9.469,1.092-15.846,1c-6.374-0.089-12.991-0.757-19.842-1.999c-6.854-1.231-13.229-4.086-19.13-8.559	c-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559 c-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-0.951-2.568-2.098-3.711-3.429c-1.142-1.331-1.997-2.663-2.568-3.997 c-0.572-1.335-0.098-2.43,1.427-3.289c1.525-0.859,4.281-1.276,8.28-1.276l5.708,0.853c3.807,0.763,8.516,3.042,14.133,6.851 c5.614,3.806,10.229,8.754,13.846,14.842c4.38,7.806,9.657,13.754,15.846,17.847c6.184,4.093,12.419,6.136,18.699,6.136	c6.28,0,11.704-0.476,16.274-1.423c4.565-0.952,8.848-2.383,12.847-4.285c1.713-12.758,6.377-22.559,13.988-29.41 c-10.848-1.14-20.601-2.857-29.264-5.14c-8.658-2.286-17.605-5.996-26.835-11.14c-9.235-5.137-16.896-11.516-22.985-19.126 c-6.09-7.614-11.088-17.61-14.987-29.979c-3.901-12.374-5.852-26.648-5.852-42.826c0-23.035,7.52-42.637,22.557-58.817 c-7.044-17.318-6.379-36.732,1.997-58.24c5.52-1.715,13.706-0.428,24.554,3.853c10.85,4.283,18.794,7.952,23.84,10.994 c5.046,3.041,9.089,5.618,12.135,7.708c17.705-4.947,35.976-7.421,54.818-7.421s37.117,2.474,54.823,7.421l10.849-6.849	c7.419-4.57,16.18-8.758,26.262-12.565c10.088-3.805,17.802-4.853,23.134-3.138c8.562,21.509,9.325,40.922,2.279,58.24 c15.036,16.18,22.559,35.787,22.559,58.817c0,16.178-1.958,30.497-5.853,42.966c-3.9,12.471-8.941,22.457-15.125,29.979	c-6.191,7.521-13.901,13.85-23.131,18.986c-9.232,5.14-18.182,8.85-26.84,11.136c-8.662,2.286-18.415,4.004-29.263,5.146 c9.894,8.562,14.842,22.077,14.842,40.539v60.237c0,3.422,1.19,6.279,3.572,8.562c2.379,2.279,6.136,2.95,11.276,1.995 c44.163-14.653,80.185-41.062,108.068-79.226c27.88-38.161,41.825-81.126,41.825-128.906 C438.536,184.851,428.728,148.168,409.132,114.573z"></path></svg></span></a><a href="https://codepen.io/wl00887404/" target="_blank" rel="noopener noreferrer"><span><!--?xml version="1.0" encoding="iso-8859-1"?--><svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="31.665px" height="31.665px" viewBox="0 0 31.665 31.665" style="enable-background:new 0 0 31.665 31.665;" xml:space="preserve"><path d="M16.878,0.415c-0.854-0.565-1.968-0.552-2.809,0.034L1.485,9.214c-0.671,0.468-1.071,1.233-1.071,2.052v9.444 c0,0.84,0.421,1.623,1.122,2.086l12.79,8.455c0.836,0.553,1.922,0.553,2.758,0l13.044-8.618c0.7-0.463,1.122-1.246,1.122-2.086 v-9.279c0-0.839-0.421-1.622-1.121-2.085L16.878,0.415z M26.621,10.645l-4.821,3.237l-4.521-3.288L17.25,4.127L26.621,10.645z M13.979,4.133v6.329l-4.633,3.24l-4.621-3.099L13.979,4.133z M3.458,13.722l2.991,2.004l-2.991,2.093V13.722z M14.058,27.215 l-9.331-6.258l4.661-3.258l4.67,3.133V27.215z M12.286,15.674l3.021-2.113l3.519,2.313l-3.119,2.095L12.286,15.674z M17.354,27.215 V20.83l4.463-2.991l4.805,3.159L17.354,27.215z M27.954,17.927l-3.168-2.082l3.168-2.125V17.927z"></path></svg></span></a><button type="button" class=""><span><!--?xml version="1.0" encoding="iso-8859-1"?--><svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve"><path d="M467.093,44.631c-31.648-31.684-73.936-46.673-115.46-44.408 c-35.997,1.964-71.419,16.97-98.836,44.408c-49.073,49.094-121.505,189.883-99.281,266.696L59.521,405.38H37.294 C16.732,405.38,0,422.123,0,442.697c0,18.877,14.089,34.537,32.299,36.984C34.755,497.902,50.385,512,69.261,512 c20.562,0,37.294-16.743,37.294-37.317v-22.24l94.138-94.196c9.559,2.763,20.147,4.381,32.063,4.381 c25.224,0,55.504-6.206,89.656-18.627c55.275-20.106,114.775-55.038,144.681-84.963c32.845-32.86,48.043-77.177,44.37-120.214 C508.529,104.444,493.331,70.881,467.093,44.631z"></path></svg></span></button></div></div><div class="container"><!-- react-empty: 17 --><div id="post"><div class="row"><div class="post"><h3 class="date">May 27, 2017</h3><h1 class="title">Javascript 非同步編程</h1><article class="body"><h2>什麼是 Promise<div class="anchor">#</div></h2>
<blockquote>
<p><strong>Promise</strong>專門用來處理異步問題，像是某人承諾幫你完成某件事情<br>
在他完成之前你可以繼續處理自己手邊的工作，當然你也可以選擇等他回來再繼續</p>
</blockquote>
<h2>在開始之前<div class="anchor">#</div></h2>
<p>先來看看在沒有 <code>Promise</code> 之前<br>
是怎麼處理異步問題的吧！<s>痛過之後你才會懂得他的好</s><br>
如果你非常熟 <code>CallBack Hell</code> ，你可以選擇跳過這段</p>
<p>下面這是一段很尋常的代碼</p>
<pre><code class="hljs" data-lang="js"><span class="hljs-keyword">const</span> Bark = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"汪汪"</span>)
}

Bark()
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我會在汪汪後執行"</span>)
</code></pre>
<p>但如果 <code>Bark</code> 是一個異步方法，情況就不同了</p>
<pre><code class="hljs" data-lang="js"><span class="hljs-comment">// Bark還是上面那個喔</span>

<span class="hljs-keyword">const</span> Bark_Delay = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    Bark()
  },<span class="hljs-number">1000</span>)
}

Bark_Delay()
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我會在汪汪後執行"</span>)
</code></pre>
<p>為了讓程式碼能正確執行<br>
我們把叫完之後要做的事包成 <code>CallBack</code><br>
等異步方法做完時呼叫</p>
<pre><code class="hljs" data-lang="js"><span class="hljs-keyword">const</span> Bark_Delay_Callback = <span class="hljs-function"><span class="hljs-params">callBack</span> =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        Bark()
        callBack()
    },<span class="hljs-number">1000</span>)
}

Bark_Delay_Callback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我會在汪汪後執行"</span>)
})
</code></pre>
<p>如此程式碼就可以正常執行了<br>
但是如果情況越來越複雜<br>
程式碼會越來越複雜,可讀性也會越來越低<br>
以常見 Ajax 的狀況來說<br>
程式碼可能長得像下面這樣</p>
<pre><code class="hljs" data-lang="js"><span class="hljs-comment">// 不用讀懂，我只是想讓你知道它長的很噁心</span>

<span class="hljs-keyword">const</span> getUserProfile = <span class="hljs-function">(<span class="hljs-params">account, password, callBack</span>) =&gt;</span> {
    checkAuth(account, password, auth =&gt; {
        <span class="hljs-keyword">if</span>(!auth){
            <span class="hljs-keyword">return</span> <span class="hljs-string">"權限錯誤"</span>
        }
        fetchUserProfile(auth, (error,rawData) =&gt; {
            <span class="hljs-keyword">if</span>(error){
                <span class="hljs-keyword">return</span> error
            }
            parseUserProfile(rawData, (error,profile) =&gt; {
                <span class="hljs-keyword">if</span>(error){
                    <span class="hljs-keyword">return</span> error
                }
                <span class="hljs-comment">// 第一個參數必須回傳 undefined</span>
                <span class="hljs-comment">// 表示沒有錯誤</span>
                callBack(<span class="hljs-literal">undefined</span>,profile)
            })
        })
    })
}

getUserProfile(<span class="hljs-string">"account"</span>, <span class="hljs-string">"password"</span>, (error,profile) =&gt; {
    <span class="hljs-keyword">if</span>(error){
        <span class="hljs-built_in">console</span>.error(error)
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"取得使用者資料成功"</span>)
})
</code></pre>
<p>是的，這個波動拳 (CallBack Hell) 是相當難維護的<br>
為了解決如此窘境，Es6 加入了 Promise</p>
<h2>Promise 正式登場！<div class="anchor">#</div></h2>
<p>我們一邊改寫 Bark 代碼一邊說明吧</p>
<pre><code class="hljs" data-lang="js"><span class="hljs-keyword">const</span> Bark_Delay_Promise = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-comment">// 呼叫 resolve ，告知 Promise 事件完成時</span>
        <span class="hljs-comment">// 呼叫 reject ，告知 Promise 有錯誤發生完成時</span>
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            Bark()
            resolve(<span class="hljs-string">"這個字串會傳進 then 裡面的 value"</span>)
        },<span class="hljs-number">1000</span>)
    })
}

Bark_Delay_Promise()
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-comment">// value = "這個字串會傳進 then 裡面的 value"</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我會在汪汪後執行"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"還可以繼續往下傳"</span>
    })
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(value)
    })
    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"Oops！好像哪邊爆炸了！"</span>)
    })

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Promise 是異步的，所以我是第一行"</span>)
</code></pre>
<p>Promise 在建構的時候必須傳入一個 CallBack<br>
CallBack 會傳入兩個方法：</p>
<ul>
<li>resolve<br>
完成時呼叫<br>
當 resolve 被呼叫會執行 <code>Promise.then</code></li>
<li>reject<br>
出錯時呼叫<br>
當 reject 被呼叫會執行 <code>Promise.catch</code></li>
</ul>
<p>使用 Promise 最顯著的優點就是解決了 CallBack Hell的問題<br>
CallBack 可以使用 Promise.then 不斷連，錯誤處理也變得更簡潔</p>
<p>剛剛上面那段很噁心的波動拳可以改成這樣</p>
<pre><code class="hljs" data-lang="js"><span class="hljs-keyword">const</span> getUserProfile = <span class="hljs-function">(<span class="hljs-params">account,password,callBack</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> checkAuth(account,password)
        .then(<span class="hljs-function"><span class="hljs-params">auth</span> =&gt;</span> {
            <span class="hljs-keyword">if</span>(!auth){
                <span class="hljs-keyword">throw</span> <span class="hljs-string">"權限錯誤"</span>
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">return</span> fetchUserProfile(auth)
            }
        })
        .then(<span class="hljs-function"><span class="hljs-params">rawData</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> parseUserProfile(rawData)
        })
}

getUserProfile(<span class="hljs-string">"account"</span>, <span class="hljs-string">"password"</span>)
    .then(<span class="hljs-function"><span class="hljs-params">profile</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"取得使用者資料成功"</span>)
    })
    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.error(error)
    })
</code></pre>
<h2>等待多個異步方法<div class="anchor">#</div></h2>
<p>你可以使用 <code>Promise.all</code> 來等待多個 Promise完成</p>
<h3>執行流程</h3>
<p><img src="./flow1.svg" alt="不！圖片去哪了！"></p>
<pre><code class="hljs" data-lang="js"><span class="hljs-keyword">const</span> Bark_Delay_3000 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            Bark()
            res(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString())
        },<span class="hljs-number">3000</span>)
    })
}

<span class="hljs-keyword">const</span> Bark_Delay_5000 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res,rej</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            Bark()
            res(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString())
        },<span class="hljs-number">5000</span>)
    })
}

<span class="hljs-keyword">var</span> promises = [
    Bark_Delay_3000(),
    Bark_Delay_5000()
]

<span class="hljs-built_in">Promise</span>.all(promises)
    .then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"--Promise.all--"</span>)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_3000:\t"</span>+ values[<span class="hljs-number">0</span>])
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_5000:\t"</span>+ values[<span class="hljs-number">1</span>])
    })

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"前面都是異步，所以我會是第一行"</span>)
</code></pre>
<p><code>Promise.all</code> 傳入一個 Promise Array，並回傳一個 Promise<br>
當 Array 裡的 Promise 全部完成的時候，執行 Promise.then<br>
Promise.then 會接到所有 Promise 回傳的值，他也是一個 Array</p>
<p>這麼一來就可以等待多個 Promise<br>
可以執行複雜的異步的任務</p>
<h2>Async/Await<div class="anchor">#</div></h2>
<p>先來看一張流程圖吧<br>
<img src="./flow2.svg" alt="揮揮衣袖不帶走一張圖片"></p>
<pre><code class="hljs" data-lang="js">Bark_Delay_3000()
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_3000:\t"</span> + value)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([
                Bark_Delay_3000(),
                Bark_Delay_5000(),
            ])
    })
    .then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"--Promise.all--"</span>)
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_3000:\t"</span>+ values[<span class="hljs-number">0</span>])
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_5000:\t"</span>+ values[<span class="hljs-number">1</span>])
    })
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_3000 是異步的，所以我會是第一行"</span>)
</code></pre>
<p>如果以 Promise 的寫法<br>
Promise 仍是不斷 then 下去，維護難度也跟著提高<br>
也因為如此在 Es7 加入了<code>Async/Await</code></p>
<pre><code class="hljs" data-lang="js"><span class="hljs-keyword">const</span> Bark_Async_Await = <span class="hljs-keyword">async</span>() =&gt; {
    <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">await</span> Bark_Delay_3000()
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_3000 :\t "</span> + value)

    values = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([
        Bark_Delay_3000(),
        Bark_Delay_5000()
    ])

    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"--Promise.all--"</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_3000:\t"</span>+ values[<span class="hljs-number">0</span>])
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Delay_5000:\t"</span>+ values[<span class="hljs-number">1</span>])

}

Bark_Async_Await()
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Bark_Async_Await 是異步的，所以我會是第一行"</span>)
</code></pre>
<p>這兩段程式碼是等價的<br>
<code>await</code> 只能用在有 <code>async</code> 修飾的 Function<br>
await 後面必須接上 Promise，會等待 Promise 執行完畢後直接回傳<br>
免除了要寫在 Promise.then 的麻煩<br>
如此程式碼就可以長得跟同步執行一模一樣<br>
可讀性更高，也更容易維護</p>
</article><div></div><div class="loader"><div></div></div></div></div><div class="row"><div class="postNav"></div></div><div class="row"><div class="gitalk"><div><div class="gt-container"><div class="gt-initing"><i class="gt-loader"></i><p class="gt-initing-text">Gitalking ...</p></div></div></div></div></div></div></div></div></div><script type="text/javascript" src="/static/js/main.f353b3a1.js"></script></body></html>